{"ast":null,"code":"/**\n * @module ol/source/UTFGrid\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport EventType from '../events/EventType.js';\nimport SourceState from './State.js';\nimport Tile from '../Tile.js';\nimport TileSource from './Tile.js';\nimport TileState from '../TileState.js';\nimport { applyTransform, intersects } from '../extent.js';\nimport { assert } from '../asserts.js';\nimport { createFromTemplates, nullTileUrlFunction } from '../tileurlfunction.js';\nimport { createXYZ, extentFromProjection } from '../tilegrid.js';\nimport { getKeyZXY } from '../tilecoord.js';\nimport { get as getProjection, getTransformFromProjections } from '../proj.js';\nimport { listenOnce } from '../events.js';\nimport { jsonp as requestJSONP } from '../net.js';\n/**\n * @typedef {Object} UTFGridJSON\n * @property {Array<string>} grid The grid.\n * @property {Array<string>} keys The keys.\n * @property {Object<string, Object>} [data] Optional data.\n */\n\nvar CustomTile = function (_super) {\n  __extends(CustomTile, _super);\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../TileState.js\").default} state State.\n   * @param {string} src Image source URI.\n   * @param {import(\"../extent.js\").Extent} extent Extent of the tile.\n   * @param {boolean} preemptive Load the tile when visible (before it's needed).\n   * @param {boolean} jsonp Load the tile as a script.\n   */\n\n\n  function CustomTile(tileCoord, state, src, extent, preemptive, jsonp) {\n    var _this = _super.call(this, tileCoord, state) || this;\n    /**\n     * @private\n     * @type {string}\n     */\n\n\n    _this.src_ = src;\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n\n    _this.extent_ = extent;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    _this.preemptive_ = preemptive;\n    /**\n     * @private\n     * @type {Array<string>}\n     */\n\n    _this.grid_ = null;\n    /**\n     * @private\n     * @type {Array<string>}\n     */\n\n    _this.keys_ = null;\n    /**\n     * @private\n     * @type {Object<string, Object>|undefined}\n     */\n\n    _this.data_ = null;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    _this.jsonp_ = jsonp;\n    return _this;\n  }\n  /**\n   * Get the image element for this tile.\n   * @return {HTMLImageElement} Image.\n   */\n\n\n  CustomTile.prototype.getImage = function () {\n    return null;\n  };\n  /**\n   * Synchronously returns data at given coordinate (if available).\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @return {*} The data.\n   */\n\n\n  CustomTile.prototype.getData = function (coordinate) {\n    if (!this.grid_ || !this.keys_) {\n      return null;\n    }\n\n    var xRelative = (coordinate[0] - this.extent_[0]) / (this.extent_[2] - this.extent_[0]);\n    var yRelative = (coordinate[1] - this.extent_[1]) / (this.extent_[3] - this.extent_[1]);\n    var row = this.grid_[Math.floor((1 - yRelative) * this.grid_.length)];\n\n    if (typeof row !== 'string') {\n      return null;\n    }\n\n    var code = row.charCodeAt(Math.floor(xRelative * row.length));\n\n    if (code >= 93) {\n      code--;\n    }\n\n    if (code >= 35) {\n      code--;\n    }\n\n    code -= 32;\n    var data = null;\n\n    if (code in this.keys_) {\n      var id = this.keys_[code];\n\n      if (this.data_ && id in this.data_) {\n        data = this.data_[id];\n      } else {\n        data = id;\n      }\n    }\n\n    return data;\n  };\n  /**\n   * Calls the callback (synchronously by default) with the available data\n   * for given coordinate (or `null` if not yet loaded).\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {function(*): void} callback Callback.\n   * @param {boolean} [opt_request] If `true` the callback is always async.\n   *                               The tile data is requested if not yet loaded.\n   */\n\n\n  CustomTile.prototype.forDataAtCoordinate = function (coordinate, callback, opt_request) {\n    if (this.state == TileState.EMPTY && opt_request === true) {\n      this.state = TileState.IDLE;\n      listenOnce(this, EventType.CHANGE, function (e) {\n        callback(this.getData(coordinate));\n      }, this);\n      this.loadInternal_();\n    } else {\n      if (opt_request === true) {\n        setTimeout(function () {\n          callback(this.getData(coordinate));\n        }.bind(this), 0);\n      } else {\n        callback(this.getData(coordinate));\n      }\n    }\n  };\n  /**\n   * Return the key to be used for all tiles in the source.\n   * @return {string} The key for all tiles.\n   */\n\n\n  CustomTile.prototype.getKey = function () {\n    return this.src_;\n  };\n  /**\n   * @private\n   */\n\n\n  CustomTile.prototype.handleError_ = function () {\n    this.state = TileState.ERROR;\n    this.changed();\n  };\n  /**\n   * @param {!UTFGridJSON} json UTFGrid data.\n   * @private\n   */\n\n\n  CustomTile.prototype.handleLoad_ = function (json) {\n    this.grid_ = json['grid'];\n    this.keys_ = json['keys'];\n    this.data_ = json['data'];\n    this.state = TileState.LOADED;\n    this.changed();\n  };\n  /**\n   * @private\n   */\n\n\n  CustomTile.prototype.loadInternal_ = function () {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n\n      if (this.jsonp_) {\n        requestJSONP(this.src_, this.handleLoad_.bind(this), this.handleError_.bind(this));\n      } else {\n        var client = new XMLHttpRequest();\n        client.addEventListener('load', this.onXHRLoad_.bind(this));\n        client.addEventListener('error', this.onXHRError_.bind(this));\n        client.open('GET', this.src_);\n        client.send();\n      }\n    }\n  };\n  /**\n   * @private\n   * @param {Event} event The load event.\n   */\n\n\n  CustomTile.prototype.onXHRLoad_ = function (event) {\n    var client = event.target; // status will be 0 for file:// urls\n\n    if (!client.status || client.status >= 200 && client.status < 300) {\n      var response = void 0;\n\n      try {\n        response = JSON.parse(client.responseText);\n      } catch (err) {\n        this.handleError_();\n        return;\n      }\n\n      this.handleLoad_(response);\n    } else {\n      this.handleError_();\n    }\n  };\n  /**\n   * @private\n   * @param {Event} event The error event.\n   */\n\n\n  CustomTile.prototype.onXHRError_ = function (event) {\n    this.handleError_();\n  };\n  /**\n   */\n\n\n  CustomTile.prototype.load = function () {\n    if (this.preemptive_) {\n      this.loadInternal_();\n    } else {\n      this.setState(TileState.EMPTY);\n    }\n  };\n\n  return CustomTile;\n}(Tile);\n\nexport { CustomTile };\n/**\n * @typedef {Object} Options\n * @property {boolean} [preemptive=true]\n * If `true` the UTFGrid source loads the tiles based on their \"visibility\".\n * This improves the speed of response, but increases traffic.\n * Note that if set to `false` (lazy loading), you need to pass `true` as\n * `opt_request` to the `forDataAtCoordinateAndResolution` method otherwise no\n * data will ever be loaded.\n * @property {boolean} [jsonp=false] Use JSONP with callback to load the TileJSON.\n * Useful when the server does not support CORS..\n * @property {import(\"./TileJSON.js\").Config} [tileJSON] TileJSON configuration for this source.\n * If not provided, `url` must be configured.\n * @property {string} [url] TileJSON endpoint that provides the configuration for this source.\n * Request will be made through JSONP. If not provided, `tileJSON` must be configured.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @classdesc\n * Layer source for UTFGrid interaction data loaded from TileJSON format.\n * @api\n */\n\nvar UTFGrid = function (_super) {\n  __extends(UTFGrid, _super);\n  /**\n   * @param {Options} options Source options.\n   */\n\n\n  function UTFGrid(options) {\n    var _this = _super.call(this, {\n      projection: getProjection('EPSG:3857'),\n      state: SourceState.LOADING,\n      zDirection: options.zDirection\n    }) || this;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n\n    _this.preemptive_ = options.preemptive !== undefined ? options.preemptive : true;\n    /**\n     * @private\n     * @type {!import(\"../Tile.js\").UrlFunction}\n     */\n\n    _this.tileUrlFunction_ = nullTileUrlFunction;\n    /**\n     * @private\n     * @type {string|undefined}\n     */\n\n    _this.template_ = undefined;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    _this.jsonp_ = options.jsonp || false;\n\n    if (options.url) {\n      if (_this.jsonp_) {\n        requestJSONP(options.url, _this.handleTileJSONResponse.bind(_this), _this.handleTileJSONError.bind(_this));\n      } else {\n        var client = new XMLHttpRequest();\n        client.addEventListener('load', _this.onXHRLoad_.bind(_this));\n        client.addEventListener('error', _this.onXHRError_.bind(_this));\n        client.open('GET', options.url);\n        client.send();\n      }\n    } else if (options.tileJSON) {\n      _this.handleTileJSONResponse(options.tileJSON);\n    } else {\n      assert(false, 51); // Either `url` or `tileJSON` options must be provided\n    }\n\n    return _this;\n  }\n  /**\n   * @private\n   * @param {Event} event The load event.\n   */\n\n\n  UTFGrid.prototype.onXHRLoad_ = function (event) {\n    var client = event.target; // status will be 0 for file:// urls\n\n    if (!client.status || client.status >= 200 && client.status < 300) {\n      var response = void 0;\n\n      try {\n        response = JSON.parse(client.responseText);\n      } catch (err) {\n        this.handleTileJSONError();\n        return;\n      }\n\n      this.handleTileJSONResponse(response);\n    } else {\n      this.handleTileJSONError();\n    }\n  };\n  /**\n   * @private\n   * @param {Event} event The error event.\n   */\n\n\n  UTFGrid.prototype.onXHRError_ = function (event) {\n    this.handleTileJSONError();\n  };\n  /**\n   * Return the template from TileJSON.\n   * @return {string|undefined} The template from TileJSON.\n   * @api\n   */\n\n\n  UTFGrid.prototype.getTemplate = function () {\n    return this.template_;\n  };\n  /**\n   * Calls the callback (synchronously by default) with the available data\n   * for given coordinate and resolution (or `null` if not yet loaded or\n   * in case of an error).\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {function(*): void} callback Callback.\n   * @param {boolean} [opt_request] If `true` the callback is always async.\n   *                               The tile data is requested if not yet loaded.\n   * @api\n   */\n\n\n  UTFGrid.prototype.forDataAtCoordinateAndResolution = function (coordinate, resolution, callback, opt_request) {\n    if (this.tileGrid) {\n      var z = this.tileGrid.getZForResolution(resolution, this.zDirection);\n      var tileCoord = this.tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      var tile = this.getTile(tileCoord[0], tileCoord[1], tileCoord[2], 1, this.getProjection());\n      tile.forDataAtCoordinate(coordinate, callback, opt_request);\n    } else {\n      if (opt_request === true) {\n        setTimeout(function () {\n          callback(null);\n        }, 0);\n      } else {\n        callback(null);\n      }\n    }\n  };\n  /**\n   * @protected\n   */\n\n\n  UTFGrid.prototype.handleTileJSONError = function () {\n    this.setState(SourceState.ERROR);\n  };\n  /**\n   * TODO: very similar to ol/source/TileJSON#handleTileJSONResponse\n   * @protected\n   * @param {import(\"./TileJSON.js\").Config} tileJSON Tile JSON.\n   */\n\n\n  UTFGrid.prototype.handleTileJSONResponse = function (tileJSON) {\n    var epsg4326Projection = getProjection('EPSG:4326');\n    var sourceProjection = this.getProjection();\n    var extent;\n\n    if (tileJSON['bounds'] !== undefined) {\n      var transform = getTransformFromProjections(epsg4326Projection, sourceProjection);\n      extent = applyTransform(tileJSON['bounds'], transform);\n    }\n\n    var gridExtent = extentFromProjection(sourceProjection);\n    var minZoom = tileJSON['minzoom'] || 0;\n    var maxZoom = tileJSON['maxzoom'] || 22;\n    var tileGrid = createXYZ({\n      extent: gridExtent,\n      maxZoom: maxZoom,\n      minZoom: minZoom\n    });\n    this.tileGrid = tileGrid;\n    this.template_ = tileJSON['template'];\n    var grids = tileJSON['grids'];\n\n    if (!grids) {\n      this.setState(SourceState.ERROR);\n      return;\n    }\n\n    this.tileUrlFunction_ = createFromTemplates(grids, tileGrid);\n\n    if (tileJSON['attribution'] !== undefined) {\n      var attributionExtent_1 = extent !== undefined ? extent : gridExtent;\n      this.setAttributions(function (frameState) {\n        if (intersects(attributionExtent_1, frameState.extent)) {\n          return [tileJSON['attribution']];\n        }\n\n        return null;\n      });\n    }\n\n    this.setState(SourceState.READY);\n  };\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!CustomTile} Tile.\n   */\n\n\n  UTFGrid.prototype.getTile = function (z, x, y, pixelRatio, projection) {\n    var tileCoordKey = getKeyZXY(z, x, y);\n\n    if (this.tileCache.containsKey(tileCoordKey)) {\n      return this.tileCache.get(tileCoordKey);\n    } else {\n      var tileCoord = [z, x, y];\n      var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);\n      var tileUrl = this.tileUrlFunction_(urlTileCoord, pixelRatio, projection);\n      var tile = new CustomTile(tileCoord, tileUrl !== undefined ? TileState.IDLE : TileState.EMPTY, tileUrl !== undefined ? tileUrl : '', this.tileGrid.getTileCoordExtent(tileCoord), this.preemptive_, this.jsonp_);\n      this.tileCache.set(tileCoordKey, tile);\n      return tile;\n    }\n  };\n  /**\n   * Marks a tile coord as being used, without triggering a load.\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   */\n\n\n  UTFGrid.prototype.useTile = function (z, x, y) {\n    var tileCoordKey = getKeyZXY(z, x, y);\n\n    if (this.tileCache.containsKey(tileCoordKey)) {\n      this.tileCache.get(tileCoordKey);\n    }\n  };\n\n  return UTFGrid;\n}(TileSource);\n\nexport default UTFGrid; //# sourceMappingURL=UTFGrid.js.map","map":{"version":3,"sources":["/home/xittz/Documentos/sa-bombeiros3/sa-bombeiros/node_modules/ol/source/UTFGrid.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","EventType","SourceState","Tile","TileSource","TileState","applyTransform","intersects","assert","createFromTemplates","nullTileUrlFunction","createXYZ","extentFromProjection","getKeyZXY","get","getProjection","getTransformFromProjections","listenOnce","jsonp","requestJSONP","CustomTile","_super","tileCoord","state","src","extent","preemptive","_this","src_","extent_","preemptive_","grid_","keys_","data_","jsonp_","getImage","getData","coordinate","xRelative","yRelative","row","Math","floor","length","code","charCodeAt","data","id","forDataAtCoordinate","callback","opt_request","EMPTY","IDLE","CHANGE","e","loadInternal_","setTimeout","bind","getKey","handleError_","ERROR","changed","handleLoad_","json","LOADED","LOADING","client","XMLHttpRequest","addEventListener","onXHRLoad_","onXHRError_","open","send","event","target","status","response","JSON","parse","responseText","err","load","setState","UTFGrid","options","projection","zDirection","undefined","tileUrlFunction_","template_","url","handleTileJSONResponse","handleTileJSONError","tileJSON","getTemplate","forDataAtCoordinateAndResolution","resolution","tileGrid","z","getZForResolution","getTileCoordForCoordAndZ","tile","getTile","epsg4326Projection","sourceProjection","transform","gridExtent","minZoom","maxZoom","grids","attributionExtent_1","setAttributions","frameState","READY","x","y","pixelRatio","tileCoordKey","tileCache","containsKey","urlTileCoord","getTileCoordForTileUrlFunction","tileUrl","getTileCoordExtent","set","useTile"],"mappings":"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","sourcesContent":["/**\n * @module ol/source/UTFGrid\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport EventType from '../events/EventType.js';\nimport SourceState from './State.js';\nimport Tile from '../Tile.js';\nimport TileSource from './Tile.js';\nimport TileState from '../TileState.js';\nimport { applyTransform, intersects } from '../extent.js';\nimport { assert } from '../asserts.js';\nimport { createFromTemplates, nullTileUrlFunction } from '../tileurlfunction.js';\nimport { createXYZ, extentFromProjection } from '../tilegrid.js';\nimport { getKeyZXY } from '../tilecoord.js';\nimport { get as getProjection, getTransformFromProjections } from '../proj.js';\nimport { listenOnce } from '../events.js';\nimport { jsonp as requestJSONP } from '../net.js';\n/**\n * @typedef {Object} UTFGridJSON\n * @property {Array<string>} grid The grid.\n * @property {Array<string>} keys The keys.\n * @property {Object<string, Object>} [data] Optional data.\n */\nvar CustomTile = /** @class */ (function (_super) {\n    __extends(CustomTile, _super);\n    /**\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @param {import(\"../TileState.js\").default} state State.\n     * @param {string} src Image source URI.\n     * @param {import(\"../extent.js\").Extent} extent Extent of the tile.\n     * @param {boolean} preemptive Load the tile when visible (before it's needed).\n     * @param {boolean} jsonp Load the tile as a script.\n     */\n    function CustomTile(tileCoord, state, src, extent, preemptive, jsonp) {\n        var _this = _super.call(this, tileCoord, state) || this;\n        /**\n         * @private\n         * @type {string}\n         */\n        _this.src_ = src;\n        /**\n         * @private\n         * @type {import(\"../extent.js\").Extent}\n         */\n        _this.extent_ = extent;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.preemptive_ = preemptive;\n        /**\n         * @private\n         * @type {Array<string>}\n         */\n        _this.grid_ = null;\n        /**\n         * @private\n         * @type {Array<string>}\n         */\n        _this.keys_ = null;\n        /**\n         * @private\n         * @type {Object<string, Object>|undefined}\n         */\n        _this.data_ = null;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.jsonp_ = jsonp;\n        return _this;\n    }\n    /**\n     * Get the image element for this tile.\n     * @return {HTMLImageElement} Image.\n     */\n    CustomTile.prototype.getImage = function () {\n        return null;\n    };\n    /**\n     * Synchronously returns data at given coordinate (if available).\n     * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @return {*} The data.\n     */\n    CustomTile.prototype.getData = function (coordinate) {\n        if (!this.grid_ || !this.keys_) {\n            return null;\n        }\n        var xRelative = (coordinate[0] - this.extent_[0]) / (this.extent_[2] - this.extent_[0]);\n        var yRelative = (coordinate[1] - this.extent_[1]) / (this.extent_[3] - this.extent_[1]);\n        var row = this.grid_[Math.floor((1 - yRelative) * this.grid_.length)];\n        if (typeof row !== 'string') {\n            return null;\n        }\n        var code = row.charCodeAt(Math.floor(xRelative * row.length));\n        if (code >= 93) {\n            code--;\n        }\n        if (code >= 35) {\n            code--;\n        }\n        code -= 32;\n        var data = null;\n        if (code in this.keys_) {\n            var id = this.keys_[code];\n            if (this.data_ && id in this.data_) {\n                data = this.data_[id];\n            }\n            else {\n                data = id;\n            }\n        }\n        return data;\n    };\n    /**\n     * Calls the callback (synchronously by default) with the available data\n     * for given coordinate (or `null` if not yet loaded).\n     * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {function(*): void} callback Callback.\n     * @param {boolean} [opt_request] If `true` the callback is always async.\n     *                               The tile data is requested if not yet loaded.\n     */\n    CustomTile.prototype.forDataAtCoordinate = function (coordinate, callback, opt_request) {\n        if (this.state == TileState.EMPTY && opt_request === true) {\n            this.state = TileState.IDLE;\n            listenOnce(this, EventType.CHANGE, function (e) {\n                callback(this.getData(coordinate));\n            }, this);\n            this.loadInternal_();\n        }\n        else {\n            if (opt_request === true) {\n                setTimeout(function () {\n                    callback(this.getData(coordinate));\n                }.bind(this), 0);\n            }\n            else {\n                callback(this.getData(coordinate));\n            }\n        }\n    };\n    /**\n     * Return the key to be used for all tiles in the source.\n     * @return {string} The key for all tiles.\n     */\n    CustomTile.prototype.getKey = function () {\n        return this.src_;\n    };\n    /**\n     * @private\n     */\n    CustomTile.prototype.handleError_ = function () {\n        this.state = TileState.ERROR;\n        this.changed();\n    };\n    /**\n     * @param {!UTFGridJSON} json UTFGrid data.\n     * @private\n     */\n    CustomTile.prototype.handleLoad_ = function (json) {\n        this.grid_ = json['grid'];\n        this.keys_ = json['keys'];\n        this.data_ = json['data'];\n        this.state = TileState.LOADED;\n        this.changed();\n    };\n    /**\n     * @private\n     */\n    CustomTile.prototype.loadInternal_ = function () {\n        if (this.state == TileState.IDLE) {\n            this.state = TileState.LOADING;\n            if (this.jsonp_) {\n                requestJSONP(this.src_, this.handleLoad_.bind(this), this.handleError_.bind(this));\n            }\n            else {\n                var client = new XMLHttpRequest();\n                client.addEventListener('load', this.onXHRLoad_.bind(this));\n                client.addEventListener('error', this.onXHRError_.bind(this));\n                client.open('GET', this.src_);\n                client.send();\n            }\n        }\n    };\n    /**\n     * @private\n     * @param {Event} event The load event.\n     */\n    CustomTile.prototype.onXHRLoad_ = function (event) {\n        var client = /** @type {XMLHttpRequest} */ (event.target);\n        // status will be 0 for file:// urls\n        if (!client.status || (client.status >= 200 && client.status < 300)) {\n            var response = void 0;\n            try {\n                response = /** @type {!UTFGridJSON} */ (JSON.parse(client.responseText));\n            }\n            catch (err) {\n                this.handleError_();\n                return;\n            }\n            this.handleLoad_(response);\n        }\n        else {\n            this.handleError_();\n        }\n    };\n    /**\n     * @private\n     * @param {Event} event The error event.\n     */\n    CustomTile.prototype.onXHRError_ = function (event) {\n        this.handleError_();\n    };\n    /**\n     */\n    CustomTile.prototype.load = function () {\n        if (this.preemptive_) {\n            this.loadInternal_();\n        }\n        else {\n            this.setState(TileState.EMPTY);\n        }\n    };\n    return CustomTile;\n}(Tile));\nexport { CustomTile };\n/**\n * @typedef {Object} Options\n * @property {boolean} [preemptive=true]\n * If `true` the UTFGrid source loads the tiles based on their \"visibility\".\n * This improves the speed of response, but increases traffic.\n * Note that if set to `false` (lazy loading), you need to pass `true` as\n * `opt_request` to the `forDataAtCoordinateAndResolution` method otherwise no\n * data will ever be loaded.\n * @property {boolean} [jsonp=false] Use JSONP with callback to load the TileJSON.\n * Useful when the server does not support CORS..\n * @property {import(\"./TileJSON.js\").Config} [tileJSON] TileJSON configuration for this source.\n * If not provided, `url` must be configured.\n * @property {string} [url] TileJSON endpoint that provides the configuration for this source.\n * Request will be made through JSONP. If not provided, `tileJSON` must be configured.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n/**\n * @classdesc\n * Layer source for UTFGrid interaction data loaded from TileJSON format.\n * @api\n */\nvar UTFGrid = /** @class */ (function (_super) {\n    __extends(UTFGrid, _super);\n    /**\n     * @param {Options} options Source options.\n     */\n    function UTFGrid(options) {\n        var _this = _super.call(this, {\n            projection: getProjection('EPSG:3857'),\n            state: SourceState.LOADING,\n            zDirection: options.zDirection,\n        }) || this;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.preemptive_ =\n            options.preemptive !== undefined ? options.preemptive : true;\n        /**\n         * @private\n         * @type {!import(\"../Tile.js\").UrlFunction}\n         */\n        _this.tileUrlFunction_ = nullTileUrlFunction;\n        /**\n         * @private\n         * @type {string|undefined}\n         */\n        _this.template_ = undefined;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.jsonp_ = options.jsonp || false;\n        if (options.url) {\n            if (_this.jsonp_) {\n                requestJSONP(options.url, _this.handleTileJSONResponse.bind(_this), _this.handleTileJSONError.bind(_this));\n            }\n            else {\n                var client = new XMLHttpRequest();\n                client.addEventListener('load', _this.onXHRLoad_.bind(_this));\n                client.addEventListener('error', _this.onXHRError_.bind(_this));\n                client.open('GET', options.url);\n                client.send();\n            }\n        }\n        else if (options.tileJSON) {\n            _this.handleTileJSONResponse(options.tileJSON);\n        }\n        else {\n            assert(false, 51); // Either `url` or `tileJSON` options must be provided\n        }\n        return _this;\n    }\n    /**\n     * @private\n     * @param {Event} event The load event.\n     */\n    UTFGrid.prototype.onXHRLoad_ = function (event) {\n        var client = /** @type {XMLHttpRequest} */ (event.target);\n        // status will be 0 for file:// urls\n        if (!client.status || (client.status >= 200 && client.status < 300)) {\n            var response = void 0;\n            try {\n                response = /** @type {import(\"./TileJSON.js\").Config} */ (JSON.parse(client.responseText));\n            }\n            catch (err) {\n                this.handleTileJSONError();\n                return;\n            }\n            this.handleTileJSONResponse(response);\n        }\n        else {\n            this.handleTileJSONError();\n        }\n    };\n    /**\n     * @private\n     * @param {Event} event The error event.\n     */\n    UTFGrid.prototype.onXHRError_ = function (event) {\n        this.handleTileJSONError();\n    };\n    /**\n     * Return the template from TileJSON.\n     * @return {string|undefined} The template from TileJSON.\n     * @api\n     */\n    UTFGrid.prototype.getTemplate = function () {\n        return this.template_;\n    };\n    /**\n     * Calls the callback (synchronously by default) with the available data\n     * for given coordinate and resolution (or `null` if not yet loaded or\n     * in case of an error).\n     * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {number} resolution Resolution.\n     * @param {function(*): void} callback Callback.\n     * @param {boolean} [opt_request] If `true` the callback is always async.\n     *                               The tile data is requested if not yet loaded.\n     * @api\n     */\n    UTFGrid.prototype.forDataAtCoordinateAndResolution = function (coordinate, resolution, callback, opt_request) {\n        if (this.tileGrid) {\n            var z = this.tileGrid.getZForResolution(resolution, this.zDirection);\n            var tileCoord = this.tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n            var tile = /** @type {!CustomTile} */ (this.getTile(tileCoord[0], tileCoord[1], tileCoord[2], 1, this.getProjection()));\n            tile.forDataAtCoordinate(coordinate, callback, opt_request);\n        }\n        else {\n            if (opt_request === true) {\n                setTimeout(function () {\n                    callback(null);\n                }, 0);\n            }\n            else {\n                callback(null);\n            }\n        }\n    };\n    /**\n     * @protected\n     */\n    UTFGrid.prototype.handleTileJSONError = function () {\n        this.setState(SourceState.ERROR);\n    };\n    /**\n     * TODO: very similar to ol/source/TileJSON#handleTileJSONResponse\n     * @protected\n     * @param {import(\"./TileJSON.js\").Config} tileJSON Tile JSON.\n     */\n    UTFGrid.prototype.handleTileJSONResponse = function (tileJSON) {\n        var epsg4326Projection = getProjection('EPSG:4326');\n        var sourceProjection = this.getProjection();\n        var extent;\n        if (tileJSON['bounds'] !== undefined) {\n            var transform = getTransformFromProjections(epsg4326Projection, sourceProjection);\n            extent = applyTransform(tileJSON['bounds'], transform);\n        }\n        var gridExtent = extentFromProjection(sourceProjection);\n        var minZoom = tileJSON['minzoom'] || 0;\n        var maxZoom = tileJSON['maxzoom'] || 22;\n        var tileGrid = createXYZ({\n            extent: gridExtent,\n            maxZoom: maxZoom,\n            minZoom: minZoom,\n        });\n        this.tileGrid = tileGrid;\n        this.template_ = tileJSON['template'];\n        var grids = tileJSON['grids'];\n        if (!grids) {\n            this.setState(SourceState.ERROR);\n            return;\n        }\n        this.tileUrlFunction_ = createFromTemplates(grids, tileGrid);\n        if (tileJSON['attribution'] !== undefined) {\n            var attributionExtent_1 = extent !== undefined ? extent : gridExtent;\n            this.setAttributions(function (frameState) {\n                if (intersects(attributionExtent_1, frameState.extent)) {\n                    return [tileJSON['attribution']];\n                }\n                return null;\n            });\n        }\n        this.setState(SourceState.READY);\n    };\n    /**\n     * @param {number} z Tile coordinate z.\n     * @param {number} x Tile coordinate x.\n     * @param {number} y Tile coordinate y.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {!CustomTile} Tile.\n     */\n    UTFGrid.prototype.getTile = function (z, x, y, pixelRatio, projection) {\n        var tileCoordKey = getKeyZXY(z, x, y);\n        if (this.tileCache.containsKey(tileCoordKey)) {\n            return this.tileCache.get(tileCoordKey);\n        }\n        else {\n            var tileCoord = [z, x, y];\n            var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);\n            var tileUrl = this.tileUrlFunction_(urlTileCoord, pixelRatio, projection);\n            var tile = new CustomTile(tileCoord, tileUrl !== undefined ? TileState.IDLE : TileState.EMPTY, tileUrl !== undefined ? tileUrl : '', this.tileGrid.getTileCoordExtent(tileCoord), this.preemptive_, this.jsonp_);\n            this.tileCache.set(tileCoordKey, tile);\n            return tile;\n        }\n    };\n    /**\n     * Marks a tile coord as being used, without triggering a load.\n     * @param {number} z Tile coordinate z.\n     * @param {number} x Tile coordinate x.\n     * @param {number} y Tile coordinate y.\n     */\n    UTFGrid.prototype.useTile = function (z, x, y) {\n        var tileCoordKey = getKeyZXY(z, x, y);\n        if (this.tileCache.containsKey(tileCoordKey)) {\n            this.tileCache.get(tileCoordKey);\n        }\n    };\n    return UTFGrid;\n}(TileSource));\nexport default UTFGrid;\n//# sourceMappingURL=UTFGrid.js.map"]},"metadata":{},"sourceType":"module"}