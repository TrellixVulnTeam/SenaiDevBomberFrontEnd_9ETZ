{"ast":null,"code":"/**\n * @module ol/source/VectorTile\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport EventType from '../events/EventType.js';\nimport Tile from '../VectorTile.js';\nimport TileCache from '../TileCache.js';\nimport TileState from '../TileState.js';\nimport UrlTile from './UrlTile.js';\nimport VectorRenderTile from '../VectorRenderTile.js';\nimport { buffer as bufferExtent, getIntersection, intersects } from '../extent.js';\nimport { createForProjection, createXYZ, extentFromProjection } from '../tilegrid.js';\nimport { fromKey, getCacheKeyForTileKey, getKeyZXY } from '../tilecoord.js';\nimport { isEmpty } from '../obj.js';\nimport { loadFeaturesXhr } from '../featureloader.js';\nimport { toSize } from '../size.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least twice the number of tiles in the viewport.\n * @property {import(\"../extent.js\").Extent} [extent] Extent.\n * @property {import(\"../format/Feature.js\").default} [format] Feature format for tiles. Used and required by the default.\n * @property {boolean} [overlaps=true] This source may have overlapping geometries. Setting this\n * to `false` (e.g. for sources with polygons that represent administrative\n * boundaries or TopoJSON sources) allows the renderer to optimise fill and\n * stroke operations.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Projection of the tile grid.\n * @property {import(\"./State.js\").default} [state] Source state.\n * @property {typeof import(\"../VectorTile.js\").default} [tileClass] Class used to instantiate image tiles.\n * Default is {@link module:ol/VectorTile}.\n * @property {number} [maxZoom=22] Optional max zoom level. Not used if `tileGrid` is provided.\n * @property {number} [minZoom] Optional min zoom level. Not used if `tileGrid` is provided.\n * @property {number|import(\"../size.js\").Size} [tileSize=512] Optional tile size. Not used if `tileGrid` is provided.\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction]\n * Optional function to load a tile given a URL. Could look like this for pbf tiles:\n * ```js\n * function(tile, url) {\n *   tile.setLoader(function(extent, resolution, projection) {\n *     fetch(url).then(function(response) {\n *       response.arrayBuffer().then(function(data) {\n *         const format = tile.getFormat() // ol/format/MVT configured as source format\n *         const features = format.readFeatures(data, {\n *           extent: extent,\n *           featureProjection: projection\n *         });\n *         tile.setFeatures(features);\n *       });\n *     });\n *   });\n * }\n * ```\n * If you do not need extent, resolution and projection to get the features for a tile (e.g.\n * for GeoJSON tiles), your `tileLoadFunction` does not need a `setLoader()` call. Only make sure\n * to call `setFeatures()` on the tile:\n * ```js\n * const format = new GeoJSON({featureProjection: map.getView().getProjection()});\n * async function tileLoadFunction(tile, url) {\n *   const response = await fetch(url);\n *   const data = await response.json();\n *   tile.setFeatures(format.readFeatures(data));\n * }\n * ```\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be\n * used instead of defining each one separately in the `urls` option.\n * @property {number} [transition] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {Array<string>} [urls] An array of URL templates.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * When set to `false`, only one world\n * will be rendered. When set to `true`, tiles will be wrapped horizontally to\n * render multiple worlds.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=1]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @classdesc\n * Class for layer sources providing vector data divided into a tile grid, to be\n * used with {@link module:ol/layer/VectorTile~VectorTile}. Although this source receives tiles\n * with vector features from the server, it is not meant for feature editing.\n * Features are optimized for rendering, their geometries are clipped at or near\n * tile boundaries and simplified for a view resolution. See\n * {@link module:ol/source/Vector} for vector sources that are suitable for feature\n * editing.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @api\n */\n\nvar VectorTile = function (_super) {\n  __extends(VectorTile, _super);\n  /**\n   * @param {!Options} options Vector tile options.\n   */\n\n\n  function VectorTile(options) {\n    var _this = this;\n\n    var projection = options.projection || 'EPSG:3857';\n    var extent = options.extent || extentFromProjection(projection);\n    var tileGrid = options.tileGrid || createXYZ({\n      extent: extent,\n      maxResolution: options.maxResolution,\n      maxZoom: options.maxZoom !== undefined ? options.maxZoom : 22,\n      minZoom: options.minZoom,\n      tileSize: options.tileSize || 512\n    });\n    _this = _super.call(this, {\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      cacheSize: options.cacheSize,\n      opaque: false,\n      projection: projection,\n      state: options.state,\n      tileGrid: tileGrid,\n      tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultLoadFunction,\n      tileUrlFunction: options.tileUrlFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX === undefined ? true : options.wrapX,\n      transition: options.transition,\n      zDirection: options.zDirection === undefined ? 1 : options.zDirection\n    }) || this;\n    /**\n     * @private\n     * @type {import(\"../format/Feature.js\").default}\n     */\n\n    _this.format_ = options.format ? options.format : null;\n    /**\n     * @private\n     * @type {TileCache}\n     */\n\n    _this.sourceTileCache = new TileCache(_this.tileCache.highWaterMark);\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    _this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;\n    /**\n     * @protected\n     * @type {typeof import(\"../VectorTile.js\").default}\n     */\n\n    _this.tileClass = options.tileClass ? options.tileClass : Tile;\n    /**\n     * @private\n     * @type {Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n     */\n\n    _this.tileGrids_ = {};\n    return _this;\n  }\n  /**\n   * Get features whose bounding box intersects the provided extent. Only features for cached\n   * tiles for the last rendered zoom level are available in the source. So this method is only\n   * suitable for requesting tiles for extents that are currently rendered.\n   *\n   * Features are returned in random tile order and as they are included in the tiles. This means\n   * they can be clipped, duplicated across tiles, and simplified to the render resolution.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {Array<import(\"../Feature.js\").FeatureLike>} Features.\n   * @api\n   */\n\n\n  VectorTile.prototype.getFeaturesInExtent = function (extent) {\n    var features = [];\n    var tileCache = this.tileCache;\n\n    if (tileCache.getCount() === 0) {\n      return features;\n    }\n\n    var z = fromKey(tileCache.peekFirstKey())[0];\n    var tileGrid = this.tileGrid;\n    tileCache.forEach(function (tile) {\n      if (tile.tileCoord[0] !== z || tile.getState() !== TileState.LOADED) {\n        return;\n      }\n\n      var sourceTiles = tile.getSourceTiles();\n\n      for (var i = 0, ii = sourceTiles.length; i < ii; ++i) {\n        var sourceTile = sourceTiles[i];\n        var tileCoord = sourceTile.tileCoord;\n\n        if (intersects(extent, tileGrid.getTileCoordExtent(tileCoord))) {\n          var tileFeatures = sourceTile.getFeatures();\n\n          if (tileFeatures) {\n            for (var j = 0, jj = tileFeatures.length; j < jj; ++j) {\n              var candidate = tileFeatures[j];\n              var geometry = candidate.getGeometry();\n\n              if (intersects(extent, geometry.getExtent())) {\n                features.push(candidate);\n              }\n            }\n          }\n        }\n      }\n    });\n    return features;\n  };\n  /**\n   * @return {boolean} The source can have overlapping geometries.\n   */\n\n\n  VectorTile.prototype.getOverlaps = function () {\n    return this.overlaps_;\n  };\n  /**\n   * clear {@link module:ol/TileCache~TileCache} and delete all source tiles\n   * @api\n   */\n\n\n  VectorTile.prototype.clear = function () {\n    this.tileCache.clear();\n    this.sourceTileCache.clear();\n  };\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\n   */\n\n\n  VectorTile.prototype.expireCache = function (projection, usedTiles) {\n    var tileCache = this.getTileCacheForProjection(projection);\n    var usedSourceTiles = Object.keys(usedTiles).reduce(function (acc, key) {\n      var cacheKey = getCacheKeyForTileKey(key);\n\n      if (tileCache.containsKey(cacheKey)) {\n        var sourceTiles = tileCache.get(cacheKey).sourceTiles;\n\n        for (var i = 0, ii = sourceTiles.length; i < ii; ++i) {\n          acc[sourceTiles[i].getKey()] = true;\n        }\n      }\n\n      return acc;\n    }, {});\n\n    _super.prototype.expireCache.call(this, projection, usedTiles);\n\n    this.sourceTileCache.expireCache(usedSourceTiles);\n  };\n  /**\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection\").default} projection Projection.\n   * @param {VectorRenderTile} tile Vector image tile.\n   * @return {Array<import(\"../VectorTile\").default>} Tile keys.\n   */\n\n\n  VectorTile.prototype.getSourceTiles = function (pixelRatio, projection, tile) {\n    var _this = this;\n\n    if (tile.getState() === TileState.IDLE) {\n      tile.setState(TileState.LOADING);\n      var urlTileCoord = tile.wrappedTileCoord;\n      var tileGrid = this.getTileGridForProjection(projection);\n      var extent = tileGrid.getTileCoordExtent(urlTileCoord);\n      var z = urlTileCoord[0];\n      var resolution = tileGrid.getResolution(z); // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n\n      bufferExtent(extent, -resolution, extent);\n      var sourceTileGrid_1 = this.tileGrid;\n      var sourceExtent = sourceTileGrid_1.getExtent();\n\n      if (sourceExtent) {\n        getIntersection(extent, sourceExtent, extent);\n      }\n\n      var sourceZ = sourceTileGrid_1.getZForResolution(resolution, 1);\n      sourceTileGrid_1.forEachTileCoord(extent, sourceZ, function (sourceTileCoord) {\n        var tileUrl = _this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);\n\n        var sourceTile = _this.sourceTileCache.containsKey(tileUrl) ? _this.sourceTileCache.get(tileUrl) : new _this.tileClass(sourceTileCoord, tileUrl ? TileState.IDLE : TileState.EMPTY, tileUrl, _this.format_, _this.tileLoadFunction);\n        tile.sourceTiles.push(sourceTile);\n        var sourceTileState = sourceTile.getState();\n\n        if (sourceTileState < TileState.LOADED) {\n          var listenChange_1 = function (event) {\n            _this.handleTileChange(event);\n\n            var state = sourceTile.getState();\n\n            if (state === TileState.LOADED || state === TileState.ERROR) {\n              var sourceTileKey = sourceTile.getKey();\n\n              if (sourceTileKey in tile.errorTileKeys) {\n                if (sourceTile.getState() === TileState.LOADED) {\n                  delete tile.errorTileKeys[sourceTileKey];\n                }\n              } else {\n                tile.loadingSourceTiles--;\n              }\n\n              if (state === TileState.ERROR) {\n                tile.errorTileKeys[sourceTileKey] = true;\n              } else {\n                sourceTile.removeEventListener(EventType.CHANGE, listenChange_1);\n              }\n\n              if (tile.loadingSourceTiles === 0) {\n                tile.setState(isEmpty(tile.errorTileKeys) ? TileState.LOADED : TileState.ERROR);\n              }\n            }\n          };\n\n          sourceTile.addEventListener(EventType.CHANGE, listenChange_1);\n          tile.loadingSourceTiles++;\n        }\n\n        if (sourceTileState === TileState.IDLE) {\n          sourceTile.extent = sourceTileGrid_1.getTileCoordExtent(sourceTileCoord);\n          sourceTile.projection = projection;\n          sourceTile.resolution = sourceTileGrid_1.getResolution(sourceTileCoord[0]);\n\n          _this.sourceTileCache.set(tileUrl, sourceTile);\n\n          sourceTile.load();\n        }\n      });\n\n      if (!tile.loadingSourceTiles) {\n        tile.setState(tile.sourceTiles.some(function (sourceTile) {\n          return sourceTile.getState() === TileState.ERROR;\n        }) ? TileState.ERROR : TileState.LOADED);\n      }\n    }\n\n    return tile.sourceTiles;\n  };\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!VectorRenderTile} Tile.\n   */\n\n\n  VectorTile.prototype.getTile = function (z, x, y, pixelRatio, projection) {\n    var coordKey = getKeyZXY(z, x, y);\n    var key = this.getKey();\n    var tile;\n\n    if (this.tileCache.containsKey(coordKey)) {\n      tile = this.tileCache.get(coordKey);\n\n      if (tile.key === key) {\n        return tile;\n      }\n    }\n\n    var tileCoord = [z, x, y];\n    var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);\n    var sourceExtent = this.getTileGrid().getExtent();\n    var tileGrid = this.getTileGridForProjection(projection);\n\n    if (urlTileCoord && sourceExtent) {\n      var tileExtent = tileGrid.getTileCoordExtent(urlTileCoord); // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n\n      bufferExtent(tileExtent, -tileGrid.getResolution(z), tileExtent);\n\n      if (!intersects(sourceExtent, tileExtent)) {\n        urlTileCoord = null;\n      }\n    }\n\n    var empty = true;\n\n    if (urlTileCoord !== null) {\n      var sourceTileGrid = this.tileGrid;\n      var resolution = tileGrid.getResolution(z);\n      var sourceZ = sourceTileGrid.getZForResolution(resolution, 1); // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n\n      var extent = tileGrid.getTileCoordExtent(urlTileCoord);\n      bufferExtent(extent, -resolution, extent);\n      sourceTileGrid.forEachTileCoord(extent, sourceZ, function (sourceTileCoord) {\n        empty = empty && !this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);\n      }.bind(this));\n    }\n\n    var newTile = new VectorRenderTile(tileCoord, empty ? TileState.EMPTY : TileState.IDLE, urlTileCoord, this.getSourceTiles.bind(this, pixelRatio, projection));\n    newTile.key = key;\n\n    if (tile) {\n      newTile.interimTile = tile;\n      newTile.refreshInterimChain();\n      this.tileCache.replace(coordKey, newTile);\n    } else {\n      this.tileCache.set(coordKey, newTile);\n    }\n\n    return newTile;\n  };\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   */\n\n\n  VectorTile.prototype.getTileGridForProjection = function (projection) {\n    var code = projection.getCode();\n    var tileGrid = this.tileGrids_[code];\n\n    if (!tileGrid) {\n      // A tile grid that matches the tile size of the source tile grid is more\n      // likely to have 1:1 relationships between source tiles and rendered tiles.\n      var sourceTileGrid = this.tileGrid;\n      tileGrid = createForProjection(projection, undefined, sourceTileGrid ? sourceTileGrid.getTileSize(sourceTileGrid.getMinZoom()) : undefined);\n      this.tileGrids_[code] = tileGrid;\n    }\n\n    return tileGrid;\n  };\n  /**\n   * Get the tile pixel ratio for this source.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {number} Tile pixel ratio.\n   */\n\n\n  VectorTile.prototype.getTilePixelRatio = function (pixelRatio) {\n    return pixelRatio;\n  };\n  /**\n   * @param {number} z Z.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../size.js\").Size} Tile size.\n   */\n\n\n  VectorTile.prototype.getTilePixelSize = function (z, pixelRatio, projection) {\n    var tileGrid = this.getTileGridForProjection(projection);\n    var tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\n    return [Math.round(tileSize[0] * pixelRatio), Math.round(tileSize[1] * pixelRatio)];\n  };\n  /**\n   * Increases the cache size if needed\n   * @param {number} tileCount Minimum number of tiles needed.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   */\n\n\n  VectorTile.prototype.updateCacheSize = function (tileCount, projection) {\n    _super.prototype.updateCacheSize.call(this, tileCount * 2, projection);\n\n    this.sourceTileCache.highWaterMark = this.getTileCacheForProjection(projection).highWaterMark;\n  };\n\n  return VectorTile;\n}(UrlTile);\n\nexport default VectorTile;\n/**\n * Sets the loader for a tile.\n * @param {import(\"../VectorTile.js\").default} tile Vector tile.\n * @param {string} url URL.\n */\n\nexport function defaultLoadFunction(tile, url) {\n  tile.setLoader(\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   */\n  function (extent, resolution, projection) {\n    loadFeaturesXhr(url, tile.getFormat(), extent, resolution, projection, tile.onLoad.bind(tile), tile.onError.bind(tile));\n  });\n} //# sourceMappingURL=VectorTile.js.map","map":{"version":3,"sources":["/home/xittz/Documentos/sa-bombeiros3/sa-bombeiros/node_modules/ol/source/VectorTile.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","EventType","Tile","TileCache","TileState","UrlTile","VectorRenderTile","buffer","bufferExtent","getIntersection","intersects","createForProjection","createXYZ","extentFromProjection","fromKey","getCacheKeyForTileKey","getKeyZXY","isEmpty","loadFeaturesXhr","toSize","VectorTile","_super","options","_this","projection","extent","tileGrid","maxResolution","maxZoom","undefined","minZoom","tileSize","attributions","attributionsCollapsible","cacheSize","opaque","state","tileLoadFunction","defaultLoadFunction","tileUrlFunction","url","urls","wrapX","transition","zDirection","format_","format","sourceTileCache","tileCache","highWaterMark","overlaps_","overlaps","tileClass","tileGrids_","getFeaturesInExtent","features","getCount","z","peekFirstKey","forEach","tile","tileCoord","getState","LOADED","sourceTiles","getSourceTiles","i","ii","length","sourceTile","getTileCoordExtent","tileFeatures","getFeatures","j","jj","candidate","geometry","getGeometry","getExtent","push","getOverlaps","clear","expireCache","usedTiles","getTileCacheForProjection","usedSourceTiles","keys","reduce","acc","key","cacheKey","containsKey","get","getKey","pixelRatio","IDLE","setState","LOADING","urlTileCoord","wrappedTileCoord","getTileGridForProjection","resolution","getResolution","sourceTileGrid_1","sourceExtent","sourceZ","getZForResolution","forEachTileCoord","sourceTileCoord","tileUrl","EMPTY","sourceTileState","listenChange_1","event","handleTileChange","ERROR","sourceTileKey","errorTileKeys","loadingSourceTiles","removeEventListener","CHANGE","addEventListener","set","load","some","getTile","x","y","coordKey","getTileCoordForTileUrlFunction","getTileGrid","tileExtent","empty","sourceTileGrid","bind","newTile","interimTile","refreshInterimChain","replace","code","getCode","getTileSize","getMinZoom","getTilePixelRatio","getTilePixelSize","tmpSize","Math","round","updateCacheSize","tileCount","setLoader","getFormat","onLoad","onError"],"mappings":"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","sourcesContent":["/**\n * @module ol/source/VectorTile\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport EventType from '../events/EventType.js';\nimport Tile from '../VectorTile.js';\nimport TileCache from '../TileCache.js';\nimport TileState from '../TileState.js';\nimport UrlTile from './UrlTile.js';\nimport VectorRenderTile from '../VectorRenderTile.js';\nimport { buffer as bufferExtent, getIntersection, intersects, } from '../extent.js';\nimport { createForProjection, createXYZ, extentFromProjection, } from '../tilegrid.js';\nimport { fromKey, getCacheKeyForTileKey, getKeyZXY } from '../tilecoord.js';\nimport { isEmpty } from '../obj.js';\nimport { loadFeaturesXhr } from '../featureloader.js';\nimport { toSize } from '../size.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least twice the number of tiles in the viewport.\n * @property {import(\"../extent.js\").Extent} [extent] Extent.\n * @property {import(\"../format/Feature.js\").default} [format] Feature format for tiles. Used and required by the default.\n * @property {boolean} [overlaps=true] This source may have overlapping geometries. Setting this\n * to `false` (e.g. for sources with polygons that represent administrative\n * boundaries or TopoJSON sources) allows the renderer to optimise fill and\n * stroke operations.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Projection of the tile grid.\n * @property {import(\"./State.js\").default} [state] Source state.\n * @property {typeof import(\"../VectorTile.js\").default} [tileClass] Class used to instantiate image tiles.\n * Default is {@link module:ol/VectorTile}.\n * @property {number} [maxZoom=22] Optional max zoom level. Not used if `tileGrid` is provided.\n * @property {number} [minZoom] Optional min zoom level. Not used if `tileGrid` is provided.\n * @property {number|import(\"../size.js\").Size} [tileSize=512] Optional tile size. Not used if `tileGrid` is provided.\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction]\n * Optional function to load a tile given a URL. Could look like this for pbf tiles:\n * ```js\n * function(tile, url) {\n *   tile.setLoader(function(extent, resolution, projection) {\n *     fetch(url).then(function(response) {\n *       response.arrayBuffer().then(function(data) {\n *         const format = tile.getFormat() // ol/format/MVT configured as source format\n *         const features = format.readFeatures(data, {\n *           extent: extent,\n *           featureProjection: projection\n *         });\n *         tile.setFeatures(features);\n *       });\n *     });\n *   });\n * }\n * ```\n * If you do not need extent, resolution and projection to get the features for a tile (e.g.\n * for GeoJSON tiles), your `tileLoadFunction` does not need a `setLoader()` call. Only make sure\n * to call `setFeatures()` on the tile:\n * ```js\n * const format = new GeoJSON({featureProjection: map.getView().getProjection()});\n * async function tileLoadFunction(tile, url) {\n *   const response = await fetch(url);\n *   const data = await response.json();\n *   tile.setFeatures(format.readFeatures(data));\n * }\n * ```\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be\n * used instead of defining each one separately in the `urls` option.\n * @property {number} [transition] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {Array<string>} [urls] An array of URL templates.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * When set to `false`, only one world\n * will be rendered. When set to `true`, tiles will be wrapped horizontally to\n * render multiple worlds.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=1]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n/**\n * @classdesc\n * Class for layer sources providing vector data divided into a tile grid, to be\n * used with {@link module:ol/layer/VectorTile~VectorTile}. Although this source receives tiles\n * with vector features from the server, it is not meant for feature editing.\n * Features are optimized for rendering, their geometries are clipped at or near\n * tile boundaries and simplified for a view resolution. See\n * {@link module:ol/source/Vector} for vector sources that are suitable for feature\n * editing.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @api\n */\nvar VectorTile = /** @class */ (function (_super) {\n    __extends(VectorTile, _super);\n    /**\n     * @param {!Options} options Vector tile options.\n     */\n    function VectorTile(options) {\n        var _this = this;\n        var projection = options.projection || 'EPSG:3857';\n        var extent = options.extent || extentFromProjection(projection);\n        var tileGrid = options.tileGrid ||\n            createXYZ({\n                extent: extent,\n                maxResolution: options.maxResolution,\n                maxZoom: options.maxZoom !== undefined ? options.maxZoom : 22,\n                minZoom: options.minZoom,\n                tileSize: options.tileSize || 512,\n            });\n        _this = _super.call(this, {\n            attributions: options.attributions,\n            attributionsCollapsible: options.attributionsCollapsible,\n            cacheSize: options.cacheSize,\n            opaque: false,\n            projection: projection,\n            state: options.state,\n            tileGrid: tileGrid,\n            tileLoadFunction: options.tileLoadFunction\n                ? options.tileLoadFunction\n                : defaultLoadFunction,\n            tileUrlFunction: options.tileUrlFunction,\n            url: options.url,\n            urls: options.urls,\n            wrapX: options.wrapX === undefined ? true : options.wrapX,\n            transition: options.transition,\n            zDirection: options.zDirection === undefined ? 1 : options.zDirection,\n        }) || this;\n        /**\n         * @private\n         * @type {import(\"../format/Feature.js\").default}\n         */\n        _this.format_ = options.format ? options.format : null;\n        /**\n         * @private\n         * @type {TileCache}\n         */\n        _this.sourceTileCache = new TileCache(_this.tileCache.highWaterMark);\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;\n        /**\n         * @protected\n         * @type {typeof import(\"../VectorTile.js\").default}\n         */\n        _this.tileClass = options.tileClass ? options.tileClass : Tile;\n        /**\n         * @private\n         * @type {Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n         */\n        _this.tileGrids_ = {};\n        return _this;\n    }\n    /**\n     * Get features whose bounding box intersects the provided extent. Only features for cached\n     * tiles for the last rendered zoom level are available in the source. So this method is only\n     * suitable for requesting tiles for extents that are currently rendered.\n     *\n     * Features are returned in random tile order and as they are included in the tiles. This means\n     * they can be clipped, duplicated across tiles, and simplified to the render resolution.\n     *\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {Array<import(\"../Feature.js\").FeatureLike>} Features.\n     * @api\n     */\n    VectorTile.prototype.getFeaturesInExtent = function (extent) {\n        var features = [];\n        var tileCache = this.tileCache;\n        if (tileCache.getCount() === 0) {\n            return features;\n        }\n        var z = fromKey(tileCache.peekFirstKey())[0];\n        var tileGrid = this.tileGrid;\n        tileCache.forEach(function (tile) {\n            if (tile.tileCoord[0] !== z || tile.getState() !== TileState.LOADED) {\n                return;\n            }\n            var sourceTiles = tile.getSourceTiles();\n            for (var i = 0, ii = sourceTiles.length; i < ii; ++i) {\n                var sourceTile = sourceTiles[i];\n                var tileCoord = sourceTile.tileCoord;\n                if (intersects(extent, tileGrid.getTileCoordExtent(tileCoord))) {\n                    var tileFeatures = sourceTile.getFeatures();\n                    if (tileFeatures) {\n                        for (var j = 0, jj = tileFeatures.length; j < jj; ++j) {\n                            var candidate = tileFeatures[j];\n                            var geometry = candidate.getGeometry();\n                            if (intersects(extent, geometry.getExtent())) {\n                                features.push(candidate);\n                            }\n                        }\n                    }\n                }\n            }\n        });\n        return features;\n    };\n    /**\n     * @return {boolean} The source can have overlapping geometries.\n     */\n    VectorTile.prototype.getOverlaps = function () {\n        return this.overlaps_;\n    };\n    /**\n     * clear {@link module:ol/TileCache~TileCache} and delete all source tiles\n     * @api\n     */\n    VectorTile.prototype.clear = function () {\n        this.tileCache.clear();\n        this.sourceTileCache.clear();\n    };\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @param {!Object<string, boolean>} usedTiles Used tiles.\n     */\n    VectorTile.prototype.expireCache = function (projection, usedTiles) {\n        var tileCache = this.getTileCacheForProjection(projection);\n        var usedSourceTiles = Object.keys(usedTiles).reduce(function (acc, key) {\n            var cacheKey = getCacheKeyForTileKey(key);\n            if (tileCache.containsKey(cacheKey)) {\n                var sourceTiles = tileCache.get(cacheKey).sourceTiles;\n                for (var i = 0, ii = sourceTiles.length; i < ii; ++i) {\n                    acc[sourceTiles[i].getKey()] = true;\n                }\n            }\n            return acc;\n        }, {});\n        _super.prototype.expireCache.call(this, projection, usedTiles);\n        this.sourceTileCache.expireCache(usedSourceTiles);\n    };\n    /**\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"../proj/Projection\").default} projection Projection.\n     * @param {VectorRenderTile} tile Vector image tile.\n     * @return {Array<import(\"../VectorTile\").default>} Tile keys.\n     */\n    VectorTile.prototype.getSourceTiles = function (pixelRatio, projection, tile) {\n        var _this = this;\n        if (tile.getState() === TileState.IDLE) {\n            tile.setState(TileState.LOADING);\n            var urlTileCoord = tile.wrappedTileCoord;\n            var tileGrid = this.getTileGridForProjection(projection);\n            var extent = tileGrid.getTileCoordExtent(urlTileCoord);\n            var z = urlTileCoord[0];\n            var resolution = tileGrid.getResolution(z);\n            // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n            bufferExtent(extent, -resolution, extent);\n            var sourceTileGrid_1 = this.tileGrid;\n            var sourceExtent = sourceTileGrid_1.getExtent();\n            if (sourceExtent) {\n                getIntersection(extent, sourceExtent, extent);\n            }\n            var sourceZ = sourceTileGrid_1.getZForResolution(resolution, 1);\n            sourceTileGrid_1.forEachTileCoord(extent, sourceZ, function (sourceTileCoord) {\n                var tileUrl = _this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);\n                var sourceTile = _this.sourceTileCache.containsKey(tileUrl)\n                    ? _this.sourceTileCache.get(tileUrl)\n                    : new _this.tileClass(sourceTileCoord, tileUrl ? TileState.IDLE : TileState.EMPTY, tileUrl, _this.format_, _this.tileLoadFunction);\n                tile.sourceTiles.push(sourceTile);\n                var sourceTileState = sourceTile.getState();\n                if (sourceTileState < TileState.LOADED) {\n                    var listenChange_1 = function (event) {\n                        _this.handleTileChange(event);\n                        var state = sourceTile.getState();\n                        if (state === TileState.LOADED || state === TileState.ERROR) {\n                            var sourceTileKey = sourceTile.getKey();\n                            if (sourceTileKey in tile.errorTileKeys) {\n                                if (sourceTile.getState() === TileState.LOADED) {\n                                    delete tile.errorTileKeys[sourceTileKey];\n                                }\n                            }\n                            else {\n                                tile.loadingSourceTiles--;\n                            }\n                            if (state === TileState.ERROR) {\n                                tile.errorTileKeys[sourceTileKey] = true;\n                            }\n                            else {\n                                sourceTile.removeEventListener(EventType.CHANGE, listenChange_1);\n                            }\n                            if (tile.loadingSourceTiles === 0) {\n                                tile.setState(isEmpty(tile.errorTileKeys)\n                                    ? TileState.LOADED\n                                    : TileState.ERROR);\n                            }\n                        }\n                    };\n                    sourceTile.addEventListener(EventType.CHANGE, listenChange_1);\n                    tile.loadingSourceTiles++;\n                }\n                if (sourceTileState === TileState.IDLE) {\n                    sourceTile.extent =\n                        sourceTileGrid_1.getTileCoordExtent(sourceTileCoord);\n                    sourceTile.projection = projection;\n                    sourceTile.resolution = sourceTileGrid_1.getResolution(sourceTileCoord[0]);\n                    _this.sourceTileCache.set(tileUrl, sourceTile);\n                    sourceTile.load();\n                }\n            });\n            if (!tile.loadingSourceTiles) {\n                tile.setState(tile.sourceTiles.some(function (sourceTile) { return sourceTile.getState() === TileState.ERROR; })\n                    ? TileState.ERROR\n                    : TileState.LOADED);\n            }\n        }\n        return tile.sourceTiles;\n    };\n    /**\n     * @param {number} z Tile coordinate z.\n     * @param {number} x Tile coordinate x.\n     * @param {number} y Tile coordinate y.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {!VectorRenderTile} Tile.\n     */\n    VectorTile.prototype.getTile = function (z, x, y, pixelRatio, projection) {\n        var coordKey = getKeyZXY(z, x, y);\n        var key = this.getKey();\n        var tile;\n        if (this.tileCache.containsKey(coordKey)) {\n            tile = this.tileCache.get(coordKey);\n            if (tile.key === key) {\n                return tile;\n            }\n        }\n        var tileCoord = [z, x, y];\n        var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);\n        var sourceExtent = this.getTileGrid().getExtent();\n        var tileGrid = this.getTileGridForProjection(projection);\n        if (urlTileCoord && sourceExtent) {\n            var tileExtent = tileGrid.getTileCoordExtent(urlTileCoord);\n            // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n            bufferExtent(tileExtent, -tileGrid.getResolution(z), tileExtent);\n            if (!intersects(sourceExtent, tileExtent)) {\n                urlTileCoord = null;\n            }\n        }\n        var empty = true;\n        if (urlTileCoord !== null) {\n            var sourceTileGrid = this.tileGrid;\n            var resolution = tileGrid.getResolution(z);\n            var sourceZ = sourceTileGrid.getZForResolution(resolution, 1);\n            // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n            var extent = tileGrid.getTileCoordExtent(urlTileCoord);\n            bufferExtent(extent, -resolution, extent);\n            sourceTileGrid.forEachTileCoord(extent, sourceZ, function (sourceTileCoord) {\n                empty =\n                    empty &&\n                        !this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);\n            }.bind(this));\n        }\n        var newTile = new VectorRenderTile(tileCoord, empty ? TileState.EMPTY : TileState.IDLE, urlTileCoord, this.getSourceTiles.bind(this, pixelRatio, projection));\n        newTile.key = key;\n        if (tile) {\n            newTile.interimTile = tile;\n            newTile.refreshInterimChain();\n            this.tileCache.replace(coordKey, newTile);\n        }\n        else {\n            this.tileCache.set(coordKey, newTile);\n        }\n        return newTile;\n    };\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n     */\n    VectorTile.prototype.getTileGridForProjection = function (projection) {\n        var code = projection.getCode();\n        var tileGrid = this.tileGrids_[code];\n        if (!tileGrid) {\n            // A tile grid that matches the tile size of the source tile grid is more\n            // likely to have 1:1 relationships between source tiles and rendered tiles.\n            var sourceTileGrid = this.tileGrid;\n            tileGrid = createForProjection(projection, undefined, sourceTileGrid\n                ? sourceTileGrid.getTileSize(sourceTileGrid.getMinZoom())\n                : undefined);\n            this.tileGrids_[code] = tileGrid;\n        }\n        return tileGrid;\n    };\n    /**\n     * Get the tile pixel ratio for this source.\n     * @param {number} pixelRatio Pixel ratio.\n     * @return {number} Tile pixel ratio.\n     */\n    VectorTile.prototype.getTilePixelRatio = function (pixelRatio) {\n        return pixelRatio;\n    };\n    /**\n     * @param {number} z Z.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {import(\"../size.js\").Size} Tile size.\n     */\n    VectorTile.prototype.getTilePixelSize = function (z, pixelRatio, projection) {\n        var tileGrid = this.getTileGridForProjection(projection);\n        var tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\n        return [\n            Math.round(tileSize[0] * pixelRatio),\n            Math.round(tileSize[1] * pixelRatio),\n        ];\n    };\n    /**\n     * Increases the cache size if needed\n     * @param {number} tileCount Minimum number of tiles needed.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     */\n    VectorTile.prototype.updateCacheSize = function (tileCount, projection) {\n        _super.prototype.updateCacheSize.call(this, tileCount * 2, projection);\n        this.sourceTileCache.highWaterMark =\n            this.getTileCacheForProjection(projection).highWaterMark;\n    };\n    return VectorTile;\n}(UrlTile));\nexport default VectorTile;\n/**\n * Sets the loader for a tile.\n * @param {import(\"../VectorTile.js\").default} tile Vector tile.\n * @param {string} url URL.\n */\nexport function defaultLoadFunction(tile, url) {\n    tile.setLoader(\n    /**\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {number} resolution Resolution.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     */\n    function (extent, resolution, projection) {\n        loadFeaturesXhr(url, tile.getFormat(), extent, resolution, projection, tile.onLoad.bind(tile), tile.onError.bind(tile));\n    });\n}\n//# sourceMappingURL=VectorTile.js.map"]},"metadata":{},"sourceType":"module"}