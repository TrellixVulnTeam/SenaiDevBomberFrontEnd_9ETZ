{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ObservablePromise = void 0;\n\nconst observable_fns_1 = require(\"observable-fns\");\n\nconst doNothing = () => undefined;\n\nconst returnInput = input => input;\n\nconst runDeferred = fn => Promise.resolve().then(fn);\n\nfunction fail(error) {\n  throw error;\n}\n\nfunction isThenable(thing) {\n  return thing && typeof thing.then === \"function\";\n}\n/**\n * Creates a hybrid, combining the APIs of an Observable and a Promise.\n *\n * It is used to proxy async process states when we are initially not sure\n * if that async process will yield values once (-> Promise) or multiple\n * times (-> Observable).\n *\n * Note that the observable promise inherits some of the observable's characteristics:\n * The `init` function will be called *once for every time anyone subscribes to it*.\n *\n * If this is undesired, derive a hot observable from it using `makeHot()` and\n * subscribe to that.\n */\n\n\nclass ObservablePromise extends observable_fns_1.Observable {\n  constructor(init) {\n    super(originalObserver => {\n      // tslint:disable-next-line no-this-assignment\n      const self = this;\n      const observer = Object.assign(Object.assign({}, originalObserver), {\n        complete() {\n          originalObserver.complete();\n          self.onCompletion();\n        },\n\n        error(error) {\n          originalObserver.error(error);\n          self.onError(error);\n        },\n\n        next(value) {\n          originalObserver.next(value);\n          self.onNext(value);\n        }\n\n      });\n\n      try {\n        this.initHasRun = true;\n        return init(observer);\n      } catch (error) {\n        observer.error(error);\n      }\n    });\n    this.initHasRun = false;\n    this.fulfillmentCallbacks = [];\n    this.rejectionCallbacks = [];\n    this.firstValueSet = false;\n    this.state = \"pending\";\n  }\n\n  onNext(value) {\n    if (!this.firstValueSet) {\n      this.firstValue = value;\n      this.firstValueSet = true;\n    }\n  }\n\n  onError(error) {\n    this.state = \"rejected\";\n    this.rejection = error;\n\n    for (const onRejected of this.rejectionCallbacks) {\n      // Promisifying the call to turn errors into unhandled promise rejections\n      // instead of them failing sync and cancelling the iteration\n      runDeferred(() => onRejected(error));\n    }\n  }\n\n  onCompletion() {\n    this.state = \"fulfilled\";\n\n    for (const onFulfilled of this.fulfillmentCallbacks) {\n      // Promisifying the call to turn errors into unhandled promise rejections\n      // instead of them failing sync and cancelling the iteration\n      runDeferred(() => onFulfilled(this.firstValue));\n    }\n  }\n\n  then(onFulfilledRaw, onRejectedRaw) {\n    const onFulfilled = onFulfilledRaw || returnInput;\n    const onRejected = onRejectedRaw || fail;\n    let onRejectedCalled = false;\n    return new Promise((resolve, reject) => {\n      const rejectionCallback = error => {\n        if (onRejectedCalled) return;\n        onRejectedCalled = true;\n\n        try {\n          resolve(onRejected(error));\n        } catch (anotherError) {\n          reject(anotherError);\n        }\n      };\n\n      const fulfillmentCallback = value => {\n        try {\n          resolve(onFulfilled(value));\n        } catch (error) {\n          rejectionCallback(error);\n        }\n      };\n\n      if (!this.initHasRun) {\n        this.subscribe({\n          error: rejectionCallback\n        });\n      }\n\n      if (this.state === \"fulfilled\") {\n        return resolve(onFulfilled(this.firstValue));\n      }\n\n      if (this.state === \"rejected\") {\n        onRejectedCalled = true;\n        return resolve(onRejected(this.rejection));\n      }\n\n      this.fulfillmentCallbacks.push(fulfillmentCallback);\n      this.rejectionCallbacks.push(rejectionCallback);\n    });\n  }\n\n  catch(onRejected) {\n    return this.then(undefined, onRejected);\n  }\n\n  finally(onCompleted) {\n    const handler = onCompleted || doNothing;\n    return this.then(value => {\n      handler();\n      return value;\n    }, () => handler());\n  }\n\n  static from(thing) {\n    if (isThenable(thing)) {\n      return new ObservablePromise(observer => {\n        const onFulfilled = value => {\n          observer.next(value);\n          observer.complete();\n        };\n\n        const onRejected = error => {\n          observer.error(error);\n        };\n\n        thing.then(onFulfilled, onRejected);\n      });\n    } else {\n      return super.from(thing);\n    }\n  }\n\n}\n\nexports.ObservablePromise = ObservablePromise;","map":{"version":3,"sources":["/home/xittz/Documentos/sa-bombeiros3/sa-bombeiros/node_modules/threads/dist/observable-promise.js"],"names":["Object","defineProperty","exports","value","ObservablePromise","observable_fns_1","require","doNothing","undefined","returnInput","input","runDeferred","fn","Promise","resolve","then","fail","error","isThenable","thing","Observable","constructor","init","originalObserver","self","observer","assign","complete","onCompletion","onError","next","onNext","initHasRun","fulfillmentCallbacks","rejectionCallbacks","firstValueSet","state","firstValue","rejection","onRejected","onFulfilled","onFulfilledRaw","onRejectedRaw","onRejectedCalled","reject","rejectionCallback","anotherError","fulfillmentCallback","subscribe","push","catch","finally","onCompleted","handler","from"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ObservablePromise = void 0;\nconst observable_fns_1 = require(\"observable-fns\");\nconst doNothing = () => undefined;\nconst returnInput = (input) => input;\nconst runDeferred = (fn) => Promise.resolve().then(fn);\nfunction fail(error) {\n    throw error;\n}\nfunction isThenable(thing) {\n    return thing && typeof thing.then === \"function\";\n}\n/**\n * Creates a hybrid, combining the APIs of an Observable and a Promise.\n *\n * It is used to proxy async process states when we are initially not sure\n * if that async process will yield values once (-> Promise) or multiple\n * times (-> Observable).\n *\n * Note that the observable promise inherits some of the observable's characteristics:\n * The `init` function will be called *once for every time anyone subscribes to it*.\n *\n * If this is undesired, derive a hot observable from it using `makeHot()` and\n * subscribe to that.\n */\nclass ObservablePromise extends observable_fns_1.Observable {\n    constructor(init) {\n        super((originalObserver) => {\n            // tslint:disable-next-line no-this-assignment\n            const self = this;\n            const observer = Object.assign(Object.assign({}, originalObserver), { complete() {\n                    originalObserver.complete();\n                    self.onCompletion();\n                }, error(error) {\n                    originalObserver.error(error);\n                    self.onError(error);\n                },\n                next(value) {\n                    originalObserver.next(value);\n                    self.onNext(value);\n                } });\n            try {\n                this.initHasRun = true;\n                return init(observer);\n            }\n            catch (error) {\n                observer.error(error);\n            }\n        });\n        this.initHasRun = false;\n        this.fulfillmentCallbacks = [];\n        this.rejectionCallbacks = [];\n        this.firstValueSet = false;\n        this.state = \"pending\";\n    }\n    onNext(value) {\n        if (!this.firstValueSet) {\n            this.firstValue = value;\n            this.firstValueSet = true;\n        }\n    }\n    onError(error) {\n        this.state = \"rejected\";\n        this.rejection = error;\n        for (const onRejected of this.rejectionCallbacks) {\n            // Promisifying the call to turn errors into unhandled promise rejections\n            // instead of them failing sync and cancelling the iteration\n            runDeferred(() => onRejected(error));\n        }\n    }\n    onCompletion() {\n        this.state = \"fulfilled\";\n        for (const onFulfilled of this.fulfillmentCallbacks) {\n            // Promisifying the call to turn errors into unhandled promise rejections\n            // instead of them failing sync and cancelling the iteration\n            runDeferred(() => onFulfilled(this.firstValue));\n        }\n    }\n    then(onFulfilledRaw, onRejectedRaw) {\n        const onFulfilled = onFulfilledRaw || returnInput;\n        const onRejected = onRejectedRaw || fail;\n        let onRejectedCalled = false;\n        return new Promise((resolve, reject) => {\n            const rejectionCallback = (error) => {\n                if (onRejectedCalled)\n                    return;\n                onRejectedCalled = true;\n                try {\n                    resolve(onRejected(error));\n                }\n                catch (anotherError) {\n                    reject(anotherError);\n                }\n            };\n            const fulfillmentCallback = (value) => {\n                try {\n                    resolve(onFulfilled(value));\n                }\n                catch (error) {\n                    rejectionCallback(error);\n                }\n            };\n            if (!this.initHasRun) {\n                this.subscribe({ error: rejectionCallback });\n            }\n            if (this.state === \"fulfilled\") {\n                return resolve(onFulfilled(this.firstValue));\n            }\n            if (this.state === \"rejected\") {\n                onRejectedCalled = true;\n                return resolve(onRejected(this.rejection));\n            }\n            this.fulfillmentCallbacks.push(fulfillmentCallback);\n            this.rejectionCallbacks.push(rejectionCallback);\n        });\n    }\n    catch(onRejected) {\n        return this.then(undefined, onRejected);\n    }\n    finally(onCompleted) {\n        const handler = onCompleted || doNothing;\n        return this.then((value) => {\n            handler();\n            return value;\n        }, () => handler());\n    }\n    static from(thing) {\n        if (isThenable(thing)) {\n            return new ObservablePromise(observer => {\n                const onFulfilled = (value) => {\n                    observer.next(value);\n                    observer.complete();\n                };\n                const onRejected = (error) => {\n                    observer.error(error);\n                };\n                thing.then(onFulfilled, onRejected);\n            });\n        }\n        else {\n            return super.from(thing);\n        }\n    }\n}\nexports.ObservablePromise = ObservablePromise;\n"]},"metadata":{},"sourceType":"script"}